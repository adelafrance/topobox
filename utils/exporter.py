import io
import zipfile
import base64
import numpy as np
import math
import ezdxf
import matplotlib
matplotlib.use('Agg')
from matplotlib.figure import Figure
from matplotlib.backends.backend_agg import FigureCanvasAgg
from matplotlib.patches import Polygon as MplPolygon, PathPatch
from matplotlib.path import Path
from matplotlib.collections import PatchCollection
from matplotlib.backends.backend_pdf import PdfPages
from shapely.geometry import Polygon
from shapely import affinity
from utils import geometry_engine

def generate_assembly_guide_pdf(final_geoms, settings, jig_modifications_dict, current_dowels):
    buffer = io.BytesIO()
    w_mm, h_mm = settings['box_w'], settings['box_h']
    wood_base = '#E3C099'
    jig_face = '#de2d26' 
    jig_edge = '#a50f15'

    def create_patch(poly, **kwargs):
        vertices = []
        codes = []
        x, y = poly.exterior.xy
        vertices.append(np.column_stack((x, y)))
        codes.append([Path.MOVETO] + [Path.LINETO] * (len(x) - 2) + [Path.CLOSEPOLY])
        for interior in poly.interiors:
            x, y = interior.xy
            vertices.append(np.column_stack((x, y)))
            codes.append([Path.MOVETO] + [Path.LINETO] * (len(x) - 2) + [Path.CLOSEPOLY])
        path = Path(np.concatenate(vertices), np.concatenate(codes))
        return PathPatch(path, **kwargs)

    def adjust_color(hex_color, factor):
        h = hex_color.lstrip('#')
        rgb = tuple(int(h[i:i+2], 16) for i in (0, 2, 4))
        new_rgb = [min(255, max(0, int(c * factor))) for c in rgb]
        return f"#{new_rgb[0]:02x}{new_rgb[1]:02x}{new_rgb[2]:02x}"

    wood_edge = adjust_color(wood_base, 0.6)
    iso_cos = math.cos(math.radians(30))
    iso_sin = math.sin(math.radians(30))
    
    def get_iso_transform(z):
        return [iso_cos, -iso_cos, iso_sin, iso_sin, 0, z]

    def draw_iso_shadowbox(ax, w, h, d):
        floor_poly = Polygon([(0,0), (w,0), (w,h), (0,h)])
        floor_proj = affinity.affine_transform(floor_poly, get_iso_transform(0))
        ax.add_patch(create_patch(floor_proj, facecolor='#333333', edgecolor='none', alpha=0.1))
        ax.add_patch(create_patch(floor_proj, facecolor='none', edgecolor='#333333', linewidth=1, linestyle='--'))

    with PdfPages(buffer) as pdf:
        # Title Page
        fig = Figure(figsize=(8.27, 11.69))
        ax = fig.add_subplot(111)
        ax.axis('off')
        ax.text(0.5, 0.90, "ASSEMBLY GUIDE", ha='center', va='bottom', fontsize=32, weight='bold', color='#2c3e50', fontfamily='sans-serif')
        ax.text(0.5, 0.85, settings.get('proj_name', 'Project'), ha='center', va='top', fontsize=20, color='#7f8c8d', fontfamily='sans-serif')
        ax.plot([0.1, 0.9], [0.82, 0.82], color='#bdc3c7', linewidth=1, transform=ax.transAxes)
        
        ax_iso = fig.add_axes([0.1, 0.40, 0.8, 0.40])
        ax_iso.axis('off')
        ax_iso.set_aspect('equal')
        total_h = len(final_geoms) * settings['mat_th']
        draw_iso_shadowbox(ax_iso, w_mm, h_mm, total_h + 5)
        
        n_layers = len(final_geoms)
        for i, layer_polys in enumerate(final_geoms):
            z_height = i * settings['mat_th']
            factor = 0.75 + (0.35 * i / max(1, n_layers - 1))
            layer_face = adjust_color(wood_base, factor)
            for p in layer_polys:
                if 'poly' in p and not p['poly'].is_empty:
                    poly = p['poly']
                    polys = [poly] if poly.geom_type == 'Polygon' else list(poly.geoms)
                    for sub in polys:
                        iso_poly = affinity.affine_transform(sub, get_iso_transform(z_height))
                        patch = create_patch(iso_poly, facecolor=layer_face, edgecolor=wood_edge, linewidth=0.3)
                        ax_iso.add_patch(patch)
        ax_iso.autoscale_view()

        info_text = (f"Dimensions: {w_mm:.0f} x {h_mm:.0f} mm\nLayers: {len(final_geoms)}\nMaterial Thickness: {settings['mat_th']:.1f} mm")
        fig.text(0.5, 0.25, info_text, ha='center', va='center', fontsize=14, color='#444444', bbox=dict(boxstyle="round,pad=1", fc="#f8f9fa", ec="#bdc3c7"))
        ax.text(0.5, 0.05, "Generated by TopoBox Pro", ha='center', va='center', fontsize=8, color='#bdc3c7', fontfamily='sans-serif')
        pdf.savefig(fig)
        
        # Layer Steps
        for i, layer in enumerate(final_geoms):
            layer_num = i + 1
            jig_mods = jig_modifications_dict.get(f"L{layer_num}", [])
            jig_data = geometry_engine.generate_jig_geometry(layer, current_dowels, w_mm, h_mm, layer_num, jig_mods, conn_width=settings['jig_conn_width'], grid_spacing=settings.get('jig_grid_spacing', 20.0), fluid_smoothing=settings.get('jig_fluid', True))
            
            fig = Figure(figsize=(8.27, 11.69))
            ax_header = fig.add_axes([0.1, 0.9, 0.8, 0.05])
            ax_header.axis('off')
            ax_header.text(0, 0.5, f"STEP {layer_num}", fontsize=24, weight='bold', color='#2c3e50', va='center')
            ax_header.text(1, 0.5, f"Layer {layer_num}", fontsize=18, color='#7f8c8d', ha='right', va='center')
            ax_header.plot([0, 1], [0, 0], color='#2c3e50', linewidth=2, transform=ax_header.transAxes)
            fig.text(0.5, 0.03, f"Page {i+2}", ha='center', fontsize=10, color='#95a5a6')
            
            ax_comp = fig.add_axes([0.1, 0.55, 0.35, 0.3])
            ax_comp.set_title("Components", fontsize=10)
            ax_comp.set_aspect('equal')
            ax_comp.set_xlim(0, w_mm); ax_comp.set_ylim(0, h_mm)
            ax_comp.axis('off')
            ax_comp.add_patch(MplPolygon([(0,0), (w_mm,0), (w_mm,h_mm), (0,h_mm)], closed=True, fc='none', ec='#dddddd', linestyle='--'))
            for p in layer:
                if 'poly' in p and not p['poly'].is_empty:
                    poly = p['poly']
                    polys = [poly] if poly.geom_type == 'Polygon' else list(poly.geoms)
                    for sub in polys:
                        patch = create_patch(sub, facecolor=wood_base, edgecolor=wood_edge, linewidth=0.5)
                        ax_comp.add_patch(patch)

            ax_jig = fig.add_axes([0.55, 0.55, 0.35, 0.3])
            ax_jig.set_title("Assembly Jig", fontsize=10)
            ax_jig.set_aspect('equal')
            ax_jig.set_xlim(0, w_mm); ax_jig.set_ylim(0, h_mm)
            ax_jig.axis('off')
            ax_jig.add_patch(MplPolygon([(0,0), (w_mm,0), (w_mm,h_mm), (0,h_mm)], closed=True, fc='none', ec='#dddddd', linestyle='--'))
            if jig_data:
                jig_poly = jig_data['poly']
                jpolys = [jig_poly] if jig_poly.geom_type == 'Polygon' else list(jig_poly.geoms)
                for jp in jpolys:
                    patch = create_patch(jp, facecolor=jig_face, edgecolor=jig_edge, alpha=0.95, linewidth=0.5)
                    ax_jig.add_patch(patch)
            else:
                ax_jig.text(w_mm/2, h_mm/2, "Self-Positioning\n(No Jig Required)", ha='center', va='center', color='#888888', fontsize=8)

            ax_stack = fig.add_axes([0.1, 0.1, 0.8, 0.4])
            ax_stack.set_title("Assembly Progress", fontsize=10)
            ax_stack.set_aspect('equal')
            ax_stack.axis('off')
            draw_iso_shadowbox(ax_stack, w_mm, h_mm, total_h + 5)
            for stack_i in range(i + 1):
                is_current = (stack_i == i)
                z_height = stack_i * settings['mat_th']
                factor = 0.75 + (0.35 * stack_i / max(1, n_layers - 1))
                layer_face = adjust_color(wood_base, factor)
                fc = layer_face if is_current else '#f0f0f0'
                ec = wood_edge if is_current else '#cccccc'
                layer_polys = final_geoms[stack_i]
                for p in layer_polys:
                    if 'poly' in p and not p['poly'].is_empty:
                        poly = p['poly']
                        polys = [poly] if poly.geom_type == 'Polygon' else list(poly.geoms)
                        for sub in polys:
                            iso_poly = affinity.affine_transform(sub, get_iso_transform(z_height))
                            patch = create_patch(iso_poly, facecolor=fc, edgecolor=ec, linewidth=0.5)
                            ax_stack.add_patch(patch)
                if is_current and jig_data:
                    jig_poly = jig_data['poly']
                    jpolys = [jig_poly] if jig_poly.geom_type == 'Polygon' else list(jig_poly.geoms)
                    for jp in jpolys:
                        iso_jig = affinity.affine_transform(jp, get_iso_transform(z_height))
                        patch = create_patch(iso_jig, facecolor=jig_face, edgecolor=jig_edge, alpha=0.95, linewidth=0.5)
                        ax_stack.add_patch(patch)
            ax_stack.autoscale_view()
            pdf.savefig(fig)
    return buffer.getvalue()

def generate_zip_data(final_geoms, settings, jig_modifications_dict, current_dowels, export_fmt):
    zip_buffer = io.BytesIO()
    w_mm, h_mm = settings['box_w'], settings['box_h']
    proj_name = settings.get('proj_name', 'Project')
    
    with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_DEFLATED) as zf:
        for i, layer in enumerate(final_geoms):
            layer_num = i + 1
            jig_mods = jig_modifications_dict.get(f"L{layer_num}", [])
            jig_data = geometry_engine.generate_jig_geometry(layer, current_dowels, w_mm, h_mm, layer_num, jig_mods, conn_width=settings['jig_conn_width'], grid_spacing=settings.get('jig_grid_spacing', 20.0), fluid_smoothing=settings.get('jig_fluid', True))
            
            if export_fmt == "SVG":
                content = geometry_engine.generate_svg_string(layer, w_mm, h_mm, fill_color="none", stroke_color="red", add_background=False)
                zf.writestr(f"Components/{proj_name}_L{layer_num}_Parts.svg", content)
                if jig_data:
                    jig_content = geometry_engine.generate_svg_string([{'poly': jig_data['poly']}], w_mm, h_mm, fill_color="none", stroke_color="blue", add_background=False)
                    zf.writestr(f"Jigs/{proj_name}_L{layer_num}_Jig.svg", jig_content)

            elif export_fmt == "DXF":
                doc = ezdxf.new()
                msp = doc.modelspace()
                for p in layer:
                    geom = p['poly']
                    if geom.is_empty: continue
                    polys = [geom] if geom.geom_type == 'Polygon' else list(geom.geoms)
                    for poly in polys:
                        if poly.is_empty: continue
                        msp.add_lwpolyline(list(poly.exterior.coords), close=True, dxfattribs={'color': 1})
                        for interior in poly.interiors: msp.add_lwpolyline(list(interior.coords), close=True, dxfattribs={'color': 1})
                dxf_stream = io.StringIO()
                doc.write(dxf_stream)
                zf.writestr(f"Components/{proj_name}_L{layer_num}_Parts.dxf", dxf_stream.getvalue())

                if jig_data:
                    doc_jig = ezdxf.new()
                    msp_jig = doc_jig.modelspace()
                    jig_poly = jig_data['poly']
                    polys = [jig_poly] if jig_poly.geom_type == 'Polygon' else list(jig_poly.geoms)
                    for poly in polys:
                        msp_jig.add_lwpolyline(list(poly.exterior.coords), close=True, dxfattribs={'color': 5})
                        for interior in poly.interiors: msp_jig.add_lwpolyline(list(interior.coords), close=True, dxfattribs={'color': 5})
                    dxf_stream_jig = io.StringIO()
                    doc_jig.write(dxf_stream_jig)
                    zf.writestr(f"Jigs/{proj_name}_L{layer_num}_Jig.dxf", dxf_stream_jig.getvalue())

            elif export_fmt in ["PDF", "PNG", "JPG"]:
                fig = Figure(figsize=(10, 10 * (h_mm / w_mm)))
                canvas = FigureCanvasAgg(fig)
                ax = fig.add_subplot(111)
                ax.set_xlim(0, w_mm); ax.set_ylim(0, h_mm); ax.set_aspect('equal'); ax.axis('off')
                patches = []
                for p in layer:
                    geom = p['poly']
                    if geom.is_empty: continue
                    polys = [geom] if geom.geom_type == 'Polygon' else list(geom.geoms)
                    for poly in polys:
                        if poly.is_empty: continue
                        patches.append(MplPolygon(np.array(poly.exterior.coords), closed=True))
                        for interior in poly.interiors: patches.append(MplPolygon(np.array(interior.coords), closed=True))
                p = PatchCollection(patches, facecolor='none', edgecolor='black', linewidth=1)
                ax.add_collection(p)
                img_data = io.BytesIO()
                canvas.print_figure(img_data, format=export_fmt.lower(), bbox_inches='tight', pad_inches=0.1)
                zf.writestr(f"Components/{proj_name}_L{layer_num}_Parts.{export_fmt.lower()}", img_data.getvalue())
                
                if jig_data:
                    fig_jig = Figure(figsize=(10, 10 * (h_mm / w_mm)))
                    canvas_jig = FigureCanvasAgg(fig_jig)
                    ax_jig = fig_jig.add_subplot(111)
                    ax_jig.set_xlim(0, w_mm); ax_jig.set_ylim(0, h_mm); ax_jig.set_aspect('equal'); ax_jig.axis('off')
                    jig_poly = jig_data['poly']
                    polys = [jig_poly] if jig_poly.geom_type == 'Polygon' else list(jig_poly.geoms)
                    jig_patches = []
                    for poly in polys:
                        jig_patches.append(MplPolygon(np.array(poly.exterior.coords), closed=True))
                        for interior in poly.interiors: jig_patches.append(MplPolygon(np.array(interior.coords), closed=True))
                    pj = PatchCollection(jig_patches, facecolor='none', edgecolor='blue', linewidth=1, linestyle='--')
                    ax_jig.add_collection(pj)
                    img_data_jig = io.BytesIO()
                    canvas_jig.print_figure(img_data_jig, format=export_fmt.lower(), bbox_inches='tight', pad_inches=0.1)
                    zf.writestr(f"Jigs/{proj_name}_L{layer_num}_Jig.{export_fmt.lower()}", img_data_jig.getvalue())

    return zip_buffer.getvalue()

def generate_nested_zip(nested_components, nested_jigs, nested_comp_dims, nested_jig_dims, export_fmt, ex_wood_color, ex_edge_color):
    buf = io.BytesIO()
    with zipfile.ZipFile(buf, "w", zipfile.ZIP_DEFLATED) as zf:
        def write_sheets(sheets, prefix, sheet_dims):
            if not sheet_dims or sheet_dims[0] == 0 or sheet_dims[1] == 0: return
            ns_w, ns_h = sheet_dims
            for i, sheet in enumerate(sheets):
                sheet_polys = []
                for placed in sheet:
                    poly = placed['data']['poly']
                    rot = placed.get('rotation', 0)
                    if rot != 0: poly = affinity.rotate(poly, rot, origin='center')
                    minx, miny, _, _ = poly.bounds
                    dx = placed['x'] - minx; dy = placed['y'] - miny
                    moved_poly = affinity.translate(poly, xoff=dx, yoff=dy)
                    sheet_polys.append({'poly': moved_poly})
                
                if export_fmt == "SVG":
                    fill = ex_wood_color if "Comp" in prefix else "#de2d26"
                    stroke = ex_edge_color if "Comp" in prefix else "#a50f15"
                    svg = geometry_engine.generate_svg_string(sheet_polys, ns_w, ns_h, fill_color=fill, stroke_color=stroke, add_background=False)
                    zf.writestr(f"{prefix}_Sheet_{i+1}.svg", svg)
                elif export_fmt == "DXF":
                    doc = ezdxf.new(); msp = doc.modelspace()
                    color = 1 if "Comp" in prefix else 5
                    for p in sheet_polys:
                        geom = p['poly']
                        if geom.is_empty: continue
                        polys = [geom] if geom.geom_type == 'Polygon' else list(geom.geoms)
                        for poly in polys:
                            if poly.is_empty: continue
                            msp.add_lwpolyline(list(poly.exterior.coords), close=True, dxfattribs={'color': color})
                            for interior in poly.interiors: msp.add_lwpolyline(list(interior.coords), close=True, dxfattribs={'color': color})
                    dxf_stream = io.StringIO(); doc.write(dxf_stream)
                    zf.writestr(f"{prefix}_Sheet_{i+1}.dxf", dxf_stream.getvalue())
        
        if nested_components and nested_comp_dims: write_sheets(nested_components, "Components/Nested", nested_comp_dims)
        if nested_jigs and nested_jig_dims: write_sheets(nested_jigs, "Jigs/Nested", nested_jig_dims)
    return buf.getvalue()